{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getEncryptionPublicKey = exports.decryptSafely = exports.decrypt = exports.encryptSafely = exports.encrypt = void 0;\n\nconst nacl = __importStar(require(\"tweetnacl\"));\n\nconst naclUtil = __importStar(require(\"tweetnacl-util\"));\n\nconst utils_1 = require(\"./utils\");\n/**\n * Encrypt a message.\n *\n * @param options - The encryption options.\n * @param options.publicKey - The public key of the message recipient.\n * @param options.data - The message data.\n * @param options.version - The type of encryption to use.\n * @returns The encrypted data.\n */\n\n\nfunction encrypt(_ref) {\n  let {\n    publicKey,\n    data,\n    version\n  } = _ref;\n\n  if (utils_1.isNullish(publicKey)) {\n    throw new Error('Missing publicKey parameter');\n  } else if (utils_1.isNullish(data)) {\n    throw new Error('Missing data parameter');\n  } else if (utils_1.isNullish(version)) {\n    throw new Error('Missing version parameter');\n  }\n\n  switch (version) {\n    case 'x25519-xsalsa20-poly1305':\n      {\n        if (typeof data !== 'string') {\n          throw new Error('Message data must be given as a string');\n        } // generate ephemeral keypair\n\n\n        const ephemeralKeyPair = nacl.box.keyPair(); // assemble encryption parameters - from string to UInt8\n\n        let pubKeyUInt8Array;\n\n        try {\n          pubKeyUInt8Array = naclUtil.decodeBase64(publicKey);\n        } catch (err) {\n          throw new Error('Bad public key');\n        }\n\n        const msgParamsUInt8Array = naclUtil.decodeUTF8(data);\n        const nonce = nacl.randomBytes(nacl.box.nonceLength); // encrypt\n\n        const encryptedMessage = nacl.box(msgParamsUInt8Array, nonce, pubKeyUInt8Array, ephemeralKeyPair.secretKey); // handle encrypted data\n\n        const output = {\n          version: 'x25519-xsalsa20-poly1305',\n          nonce: naclUtil.encodeBase64(nonce),\n          ephemPublicKey: naclUtil.encodeBase64(ephemeralKeyPair.publicKey),\n          ciphertext: naclUtil.encodeBase64(encryptedMessage)\n        }; // return encrypted msg data\n\n        return output;\n      }\n\n    default:\n      throw new Error('Encryption type/version not supported');\n  }\n}\n\nexports.encrypt = encrypt;\n/**\n * Encrypt a message in a way that obscures the message length.\n *\n * The message is padded to a multiple of 2048 before being encrypted so that the length of the\n * resulting encrypted message can't be used to guess the exact length of the original message.\n *\n * @param options - The encryption options.\n * @param options.publicKey - The public key of the message recipient.\n * @param options.data - The message data.\n * @param options.version - The type of encryption to use.\n * @returns The encrypted data.\n */\n\nfunction encryptSafely(_ref2) {\n  let {\n    publicKey,\n    data,\n    version\n  } = _ref2;\n\n  if (utils_1.isNullish(publicKey)) {\n    throw new Error('Missing publicKey parameter');\n  } else if (utils_1.isNullish(data)) {\n    throw new Error('Missing data parameter');\n  } else if (utils_1.isNullish(version)) {\n    throw new Error('Missing version parameter');\n  }\n\n  const DEFAULT_PADDING_LENGTH = 2 ** 11;\n  const NACL_EXTRA_BYTES = 16;\n\n  if (typeof data === 'object' && 'toJSON' in data) {\n    // remove toJSON attack vector\n    // TODO, check all possible children\n    throw new Error('Cannot encrypt with toJSON property.  Please remove toJSON property');\n  } // add padding\n\n\n  const dataWithPadding = {\n    data,\n    padding: ''\n  }; // calculate padding\n\n  const dataLength = Buffer.byteLength(JSON.stringify(dataWithPadding), 'utf-8');\n  const modVal = dataLength % DEFAULT_PADDING_LENGTH;\n  let padLength = 0; // Only pad if necessary\n\n  if (modVal > 0) {\n    padLength = DEFAULT_PADDING_LENGTH - modVal - NACL_EXTRA_BYTES; // nacl extra bytes\n  }\n\n  dataWithPadding.padding = '0'.repeat(padLength);\n  const paddedMessage = JSON.stringify(dataWithPadding);\n  return encrypt({\n    publicKey,\n    data: paddedMessage,\n    version\n  });\n}\n\nexports.encryptSafely = encryptSafely;\n/**\n * Decrypt a message.\n *\n * @param options - The decryption options.\n * @param options.encryptedData - The encrypted data.\n * @param options.privateKey - The private key to decrypt with.\n * @returns The decrypted message.\n */\n\nfunction decrypt(_ref3) {\n  let {\n    encryptedData,\n    privateKey\n  } = _ref3;\n\n  if (utils_1.isNullish(encryptedData)) {\n    throw new Error('Missing encryptedData parameter');\n  } else if (utils_1.isNullish(privateKey)) {\n    throw new Error('Missing privateKey parameter');\n  }\n\n  switch (encryptedData.version) {\n    case 'x25519-xsalsa20-poly1305':\n      {\n        // string to buffer to UInt8Array\n        const recieverPrivateKeyUint8Array = nacl_decodeHex(privateKey);\n        const recieverEncryptionPrivateKey = nacl.box.keyPair.fromSecretKey(recieverPrivateKeyUint8Array).secretKey; // assemble decryption parameters\n\n        const nonce = naclUtil.decodeBase64(encryptedData.nonce);\n        const ciphertext = naclUtil.decodeBase64(encryptedData.ciphertext);\n        const ephemPublicKey = naclUtil.decodeBase64(encryptedData.ephemPublicKey); // decrypt\n\n        const decryptedMessage = nacl.box.open(ciphertext, nonce, ephemPublicKey, recieverEncryptionPrivateKey); // return decrypted msg data\n\n        let output;\n\n        try {\n          output = naclUtil.encodeUTF8(decryptedMessage);\n        } catch (err) {\n          throw new Error('Decryption failed.');\n        }\n\n        if (output) {\n          return output;\n        }\n\n        throw new Error('Decryption failed.');\n      }\n\n    default:\n      throw new Error('Encryption type/version not supported.');\n  }\n}\n\nexports.decrypt = decrypt;\n/**\n * Decrypt a message that has been encrypted using `encryptSafely`.\n *\n * @param options - The decryption options.\n * @param options.encryptedData - The encrypted data.\n * @param options.privateKey - The private key to decrypt with.\n * @returns The decrypted message.\n */\n\nfunction decryptSafely(_ref4) {\n  let {\n    encryptedData,\n    privateKey\n  } = _ref4;\n\n  if (utils_1.isNullish(encryptedData)) {\n    throw new Error('Missing encryptedData parameter');\n  } else if (utils_1.isNullish(privateKey)) {\n    throw new Error('Missing privateKey parameter');\n  }\n\n  const dataWithPadding = JSON.parse(decrypt({\n    encryptedData,\n    privateKey\n  }));\n  return dataWithPadding.data;\n}\n\nexports.decryptSafely = decryptSafely;\n/**\n * Get the encryption public key for the given key.\n *\n * @param privateKey - The private key to generate the encryption public key with.\n * @returns The encryption public key.\n */\n\nfunction getEncryptionPublicKey(privateKey) {\n  const privateKeyUint8Array = nacl_decodeHex(privateKey);\n  const encryptionPublicKey = nacl.box.keyPair.fromSecretKey(privateKeyUint8Array).publicKey;\n  return naclUtil.encodeBase64(encryptionPublicKey);\n}\n\nexports.getEncryptionPublicKey = getEncryptionPublicKey;\n/**\n * Convert a hex string to the UInt8Array format used by nacl.\n *\n * @param msgHex - The string to convert.\n * @returns The converted string.\n */\n\nfunction nacl_decodeHex(msgHex) {\n  const msgBase64 = Buffer.from(msgHex, 'hex').toString('base64');\n  return naclUtil.decodeBase64(msgBase64);\n}","map":{"version":3,"mappings":"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","names":["encrypt","publicKey","data","version","utils_1","Error","ephemeralKeyPair","nacl","box","keyPair","pubKeyUInt8Array","naclUtil","decodeBase64","err","msgParamsUInt8Array","decodeUTF8","nonce","randomBytes","nonceLength","encryptedMessage","secretKey","output","encodeBase64","ephemPublicKey","ciphertext","exports","encryptSafely","DEFAULT_PADDING_LENGTH","NACL_EXTRA_BYTES","dataWithPadding","padding","dataLength","Buffer","byteLength","JSON","stringify","modVal","padLength","repeat","paddedMessage","decrypt","encryptedData","privateKey","recieverPrivateKeyUint8Array","nacl_decodeHex","recieverEncryptionPrivateKey","fromSecretKey","decryptedMessage","open","encodeUTF8","decryptSafely","parse","getEncryptionPublicKey","privateKeyUint8Array","encryptionPublicKey","msgHex","msgBase64","from","toString"],"sourceRoot":"","sources":["../src/encryption.ts"],"sourcesContent":["import * as nacl from 'tweetnacl';\nimport * as naclUtil from 'tweetnacl-util';\n\nimport { isNullish } from './utils';\n\nexport interface EthEncryptedData {\n  version: string;\n  nonce: string;\n  ephemPublicKey: string;\n  ciphertext: string;\n}\n\n/**\n * Encrypt a message.\n *\n * @param options - The encryption options.\n * @param options.publicKey - The public key of the message recipient.\n * @param options.data - The message data.\n * @param options.version - The type of encryption to use.\n * @returns The encrypted data.\n */\nexport function encrypt({\n  publicKey,\n  data,\n  version,\n}: {\n  publicKey: string;\n  data: unknown;\n  version: string;\n}): EthEncryptedData {\n  if (isNullish(publicKey)) {\n    throw new Error('Missing publicKey parameter');\n  } else if (isNullish(data)) {\n    throw new Error('Missing data parameter');\n  } else if (isNullish(version)) {\n    throw new Error('Missing version parameter');\n  }\n\n  switch (version) {\n    case 'x25519-xsalsa20-poly1305': {\n      if (typeof data !== 'string') {\n        throw new Error('Message data must be given as a string');\n      }\n      // generate ephemeral keypair\n      const ephemeralKeyPair = nacl.box.keyPair();\n\n      // assemble encryption parameters - from string to UInt8\n      let pubKeyUInt8Array;\n      try {\n        pubKeyUInt8Array = naclUtil.decodeBase64(publicKey);\n      } catch (err) {\n        throw new Error('Bad public key');\n      }\n\n      const msgParamsUInt8Array = naclUtil.decodeUTF8(data);\n      const nonce = nacl.randomBytes(nacl.box.nonceLength);\n\n      // encrypt\n      const encryptedMessage = nacl.box(\n        msgParamsUInt8Array,\n        nonce,\n        pubKeyUInt8Array,\n        ephemeralKeyPair.secretKey,\n      );\n\n      // handle encrypted data\n      const output = {\n        version: 'x25519-xsalsa20-poly1305',\n        nonce: naclUtil.encodeBase64(nonce),\n        ephemPublicKey: naclUtil.encodeBase64(ephemeralKeyPair.publicKey),\n        ciphertext: naclUtil.encodeBase64(encryptedMessage),\n      };\n      // return encrypted msg data\n      return output;\n    }\n\n    default:\n      throw new Error('Encryption type/version not supported');\n  }\n}\n\n/**\n * Encrypt a message in a way that obscures the message length.\n *\n * The message is padded to a multiple of 2048 before being encrypted so that the length of the\n * resulting encrypted message can't be used to guess the exact length of the original message.\n *\n * @param options - The encryption options.\n * @param options.publicKey - The public key of the message recipient.\n * @param options.data - The message data.\n * @param options.version - The type of encryption to use.\n * @returns The encrypted data.\n */\nexport function encryptSafely({\n  publicKey,\n  data,\n  version,\n}: {\n  publicKey: string;\n  data: unknown;\n  version: string;\n}): EthEncryptedData {\n  if (isNullish(publicKey)) {\n    throw new Error('Missing publicKey parameter');\n  } else if (isNullish(data)) {\n    throw new Error('Missing data parameter');\n  } else if (isNullish(version)) {\n    throw new Error('Missing version parameter');\n  }\n\n  const DEFAULT_PADDING_LENGTH = 2 ** 11;\n  const NACL_EXTRA_BYTES = 16;\n\n  if (typeof data === 'object' && 'toJSON' in data) {\n    // remove toJSON attack vector\n    // TODO, check all possible children\n    throw new Error(\n      'Cannot encrypt with toJSON property.  Please remove toJSON property',\n    );\n  }\n\n  // add padding\n  const dataWithPadding = {\n    data,\n    padding: '',\n  };\n\n  // calculate padding\n  const dataLength = Buffer.byteLength(\n    JSON.stringify(dataWithPadding),\n    'utf-8',\n  );\n  const modVal = dataLength % DEFAULT_PADDING_LENGTH;\n  let padLength = 0;\n  // Only pad if necessary\n  if (modVal > 0) {\n    padLength = DEFAULT_PADDING_LENGTH - modVal - NACL_EXTRA_BYTES; // nacl extra bytes\n  }\n  dataWithPadding.padding = '0'.repeat(padLength);\n\n  const paddedMessage = JSON.stringify(dataWithPadding);\n  return encrypt({ publicKey, data: paddedMessage, version });\n}\n\n/**\n * Decrypt a message.\n *\n * @param options - The decryption options.\n * @param options.encryptedData - The encrypted data.\n * @param options.privateKey - The private key to decrypt with.\n * @returns The decrypted message.\n */\nexport function decrypt({\n  encryptedData,\n  privateKey,\n}: {\n  encryptedData: EthEncryptedData;\n  privateKey: string;\n}): string {\n  if (isNullish(encryptedData)) {\n    throw new Error('Missing encryptedData parameter');\n  } else if (isNullish(privateKey)) {\n    throw new Error('Missing privateKey parameter');\n  }\n\n  switch (encryptedData.version) {\n    case 'x25519-xsalsa20-poly1305': {\n      // string to buffer to UInt8Array\n      const recieverPrivateKeyUint8Array = nacl_decodeHex(privateKey);\n      const recieverEncryptionPrivateKey = nacl.box.keyPair.fromSecretKey(\n        recieverPrivateKeyUint8Array,\n      ).secretKey;\n\n      // assemble decryption parameters\n      const nonce = naclUtil.decodeBase64(encryptedData.nonce);\n      const ciphertext = naclUtil.decodeBase64(encryptedData.ciphertext);\n      const ephemPublicKey = naclUtil.decodeBase64(\n        encryptedData.ephemPublicKey,\n      );\n\n      // decrypt\n      const decryptedMessage = nacl.box.open(\n        ciphertext,\n        nonce,\n        ephemPublicKey,\n        recieverEncryptionPrivateKey,\n      );\n\n      // return decrypted msg data\n      let output;\n      try {\n        output = naclUtil.encodeUTF8(decryptedMessage);\n      } catch (err) {\n        throw new Error('Decryption failed.');\n      }\n\n      if (output) {\n        return output;\n      }\n      throw new Error('Decryption failed.');\n    }\n\n    default:\n      throw new Error('Encryption type/version not supported.');\n  }\n}\n\n/**\n * Decrypt a message that has been encrypted using `encryptSafely`.\n *\n * @param options - The decryption options.\n * @param options.encryptedData - The encrypted data.\n * @param options.privateKey - The private key to decrypt with.\n * @returns The decrypted message.\n */\nexport function decryptSafely({\n  encryptedData,\n  privateKey,\n}: {\n  encryptedData: EthEncryptedData;\n  privateKey: string;\n}): string {\n  if (isNullish(encryptedData)) {\n    throw new Error('Missing encryptedData parameter');\n  } else if (isNullish(privateKey)) {\n    throw new Error('Missing privateKey parameter');\n  }\n\n  const dataWithPadding = JSON.parse(decrypt({ encryptedData, privateKey }));\n  return dataWithPadding.data;\n}\n\n/**\n * Get the encryption public key for the given key.\n *\n * @param privateKey - The private key to generate the encryption public key with.\n * @returns The encryption public key.\n */\nexport function getEncryptionPublicKey(privateKey: string): string {\n  const privateKeyUint8Array = nacl_decodeHex(privateKey);\n  const encryptionPublicKey =\n    nacl.box.keyPair.fromSecretKey(privateKeyUint8Array).publicKey;\n  return naclUtil.encodeBase64(encryptionPublicKey);\n}\n\n/**\n * Convert a hex string to the UInt8Array format used by nacl.\n *\n * @param msgHex - The string to convert.\n * @returns The converted string.\n */\nfunction nacl_decodeHex(msgHex: string): Uint8Array {\n  const msgBase64 = Buffer.from(msgHex, 'hex').toString('base64');\n  return naclUtil.decodeBase64(msgBase64);\n}\n"]},"metadata":{},"sourceType":"script"}