{"ast":null,"code":"\"use strict\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version); ///////////////////////////////\n\nfunction isHexable(value) {\n  return !!value.toHexString;\n}\n\nfunction addSlice(array) {\n  if (array.slice) {\n    return array;\n  }\n\n  array.slice = function () {\n    const args = Array.prototype.slice.call(arguments);\n    return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));\n  };\n\n  return array;\n}\n\nexport function isBytesLike(value) {\n  return isHexString(value) && !(value.length % 2) || isBytes(value);\n}\n\nfunction isInteger(value) {\n  return typeof value === \"number\" && value == value && value % 1 === 0;\n}\n\nexport function isBytes(value) {\n  if (value == null) {\n    return false;\n  }\n\n  if (value.constructor === Uint8Array) {\n    return true;\n  }\n\n  if (typeof value === \"string\") {\n    return false;\n  }\n\n  if (!isInteger(value.length) || value.length < 0) {\n    return false;\n  }\n\n  for (let i = 0; i < value.length; i++) {\n    const v = value[i];\n\n    if (!isInteger(v) || v < 0 || v >= 256) {\n      return false;\n    }\n  }\n\n  return true;\n}\nexport function arrayify(value, options) {\n  if (!options) {\n    options = {};\n  }\n\n  if (typeof value === \"number\") {\n    logger.checkSafeUint53(value, \"invalid arrayify value\");\n    const result = [];\n\n    while (value) {\n      result.unshift(value & 0xff);\n      value = parseInt(String(value / 256));\n    }\n\n    if (result.length === 0) {\n      result.push(0);\n    }\n\n    return addSlice(new Uint8Array(result));\n  }\n\n  if (options.allowMissingPrefix && typeof value === \"string\" && value.substring(0, 2) !== \"0x\") {\n    value = \"0x\" + value;\n  }\n\n  if (isHexable(value)) {\n    value = value.toHexString();\n  }\n\n  if (isHexString(value)) {\n    let hex = value.substring(2);\n\n    if (hex.length % 2) {\n      if (options.hexPad === \"left\") {\n        hex = \"0\" + hex;\n      } else if (options.hexPad === \"right\") {\n        hex += \"0\";\n      } else {\n        logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n      }\n    }\n\n    const result = [];\n\n    for (let i = 0; i < hex.length; i += 2) {\n      result.push(parseInt(hex.substring(i, i + 2), 16));\n    }\n\n    return addSlice(new Uint8Array(result));\n  }\n\n  if (isBytes(value)) {\n    return addSlice(new Uint8Array(value));\n  }\n\n  return logger.throwArgumentError(\"invalid arrayify value\", \"value\", value);\n}\nexport function concat(items) {\n  const objects = items.map(item => arrayify(item));\n  const length = objects.reduce((accum, item) => accum + item.length, 0);\n  const result = new Uint8Array(length);\n  objects.reduce((offset, object) => {\n    result.set(object, offset);\n    return offset + object.length;\n  }, 0);\n  return addSlice(result);\n}\nexport function stripZeros(value) {\n  let result = arrayify(value);\n\n  if (result.length === 0) {\n    return result;\n  } // Find the first non-zero entry\n\n\n  let start = 0;\n\n  while (start < result.length && result[start] === 0) {\n    start++;\n  } // If we started with zeros, strip them\n\n\n  if (start) {\n    result = result.slice(start);\n  }\n\n  return result;\n}\nexport function zeroPad(value, length) {\n  value = arrayify(value);\n\n  if (value.length > length) {\n    logger.throwArgumentError(\"value out of range\", \"value\", arguments[0]);\n  }\n\n  const result = new Uint8Array(length);\n  result.set(value, length - value.length);\n  return addSlice(result);\n}\nexport function isHexString(value, length) {\n  if (typeof value !== \"string\" || !value.match(/^0x[0-9A-Fa-f]*$/)) {\n    return false;\n  }\n\n  if (length && value.length !== 2 + 2 * length) {\n    return false;\n  }\n\n  return true;\n}\nconst HexCharacters = \"0123456789abcdef\";\nexport function hexlify(value, options) {\n  if (!options) {\n    options = {};\n  }\n\n  if (typeof value === \"number\") {\n    logger.checkSafeUint53(value, \"invalid hexlify value\");\n    let hex = \"\";\n\n    while (value) {\n      hex = HexCharacters[value & 0xf] + hex;\n      value = Math.floor(value / 16);\n    }\n\n    if (hex.length) {\n      if (hex.length % 2) {\n        hex = \"0\" + hex;\n      }\n\n      return \"0x\" + hex;\n    }\n\n    return \"0x00\";\n  }\n\n  if (typeof value === \"bigint\") {\n    value = value.toString(16);\n\n    if (value.length % 2) {\n      return \"0x0\" + value;\n    }\n\n    return \"0x\" + value;\n  }\n\n  if (options.allowMissingPrefix && typeof value === \"string\" && value.substring(0, 2) !== \"0x\") {\n    value = \"0x\" + value;\n  }\n\n  if (isHexable(value)) {\n    return value.toHexString();\n  }\n\n  if (isHexString(value)) {\n    if (value.length % 2) {\n      if (options.hexPad === \"left\") {\n        value = \"0x0\" + value.substring(2);\n      } else if (options.hexPad === \"right\") {\n        value += \"0\";\n      } else {\n        logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n      }\n    }\n\n    return value.toLowerCase();\n  }\n\n  if (isBytes(value)) {\n    let result = \"0x\";\n\n    for (let i = 0; i < value.length; i++) {\n      let v = value[i];\n      result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];\n    }\n\n    return result;\n  }\n\n  return logger.throwArgumentError(\"invalid hexlify value\", \"value\", value);\n}\n/*\r\nfunction unoddify(value: BytesLike | Hexable | number): BytesLike | Hexable | number {\r\n    if (typeof(value) === \"string\" && value.length % 2 && value.substring(0, 2) === \"0x\") {\r\n        return \"0x0\" + value.substring(2);\r\n    }\r\n    return value;\r\n}\r\n*/\n\nexport function hexDataLength(data) {\n  if (typeof data !== \"string\") {\n    data = hexlify(data);\n  } else if (!isHexString(data) || data.length % 2) {\n    return null;\n  }\n\n  return (data.length - 2) / 2;\n}\nexport function hexDataSlice(data, offset, endOffset) {\n  if (typeof data !== \"string\") {\n    data = hexlify(data);\n  } else if (!isHexString(data) || data.length % 2) {\n    logger.throwArgumentError(\"invalid hexData\", \"value\", data);\n  }\n\n  offset = 2 + 2 * offset;\n\n  if (endOffset != null) {\n    return \"0x\" + data.substring(offset, 2 + 2 * endOffset);\n  }\n\n  return \"0x\" + data.substring(offset);\n}\nexport function hexConcat(items) {\n  let result = \"0x\";\n  items.forEach(item => {\n    result += hexlify(item).substring(2);\n  });\n  return result;\n}\nexport function hexValue(value) {\n  const trimmed = hexStripZeros(hexlify(value, {\n    hexPad: \"left\"\n  }));\n\n  if (trimmed === \"0x\") {\n    return \"0x0\";\n  }\n\n  return trimmed;\n}\nexport function hexStripZeros(value) {\n  if (typeof value !== \"string\") {\n    value = hexlify(value);\n  }\n\n  if (!isHexString(value)) {\n    logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n  }\n\n  value = value.substring(2);\n  let offset = 0;\n\n  while (offset < value.length && value[offset] === \"0\") {\n    offset++;\n  }\n\n  return \"0x\" + value.substring(offset);\n}\nexport function hexZeroPad(value, length) {\n  if (typeof value !== \"string\") {\n    value = hexlify(value);\n  } else if (!isHexString(value)) {\n    logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n  }\n\n  if (value.length > 2 * length + 2) {\n    logger.throwArgumentError(\"value out of range\", \"value\", arguments[1]);\n  }\n\n  while (value.length < 2 * length + 2) {\n    value = \"0x0\" + value.substring(2);\n  }\n\n  return value;\n}\nexport function splitSignature(signature) {\n  const result = {\n    r: \"0x\",\n    s: \"0x\",\n    _vs: \"0x\",\n    recoveryParam: 0,\n    v: 0,\n    yParityAndS: \"0x\",\n    compact: \"0x\"\n  };\n\n  if (isBytesLike(signature)) {\n    let bytes = arrayify(signature); // Get the r, s and v\n\n    if (bytes.length === 64) {\n      // EIP-2098; pull the v from the top bit of s and clear it\n      result.v = 27 + (bytes[32] >> 7);\n      bytes[32] &= 0x7f;\n      result.r = hexlify(bytes.slice(0, 32));\n      result.s = hexlify(bytes.slice(32, 64));\n    } else if (bytes.length === 65) {\n      result.r = hexlify(bytes.slice(0, 32));\n      result.s = hexlify(bytes.slice(32, 64));\n      result.v = bytes[64];\n    } else {\n      logger.throwArgumentError(\"invalid signature string\", \"signature\", signature);\n    } // Allow a recid to be used as the v\n\n\n    if (result.v < 27) {\n      if (result.v === 0 || result.v === 1) {\n        result.v += 27;\n      } else {\n        logger.throwArgumentError(\"signature invalid v byte\", \"signature\", signature);\n      }\n    } // Compute recoveryParam from v\n\n\n    result.recoveryParam = 1 - result.v % 2; // Compute _vs from recoveryParam and s\n\n    if (result.recoveryParam) {\n      bytes[32] |= 0x80;\n    }\n\n    result._vs = hexlify(bytes.slice(32, 64));\n  } else {\n    result.r = signature.r;\n    result.s = signature.s;\n    result.v = signature.v;\n    result.recoveryParam = signature.recoveryParam;\n    result._vs = signature._vs; // If the _vs is available, use it to populate missing s, v and recoveryParam\n    // and verify non-missing s, v and recoveryParam\n\n    if (result._vs != null) {\n      const vs = zeroPad(arrayify(result._vs), 32);\n      result._vs = hexlify(vs); // Set or check the recid\n\n      const recoveryParam = vs[0] >= 128 ? 1 : 0;\n\n      if (result.recoveryParam == null) {\n        result.recoveryParam = recoveryParam;\n      } else if (result.recoveryParam !== recoveryParam) {\n        logger.throwArgumentError(\"signature recoveryParam mismatch _vs\", \"signature\", signature);\n      } // Set or check the s\n\n\n      vs[0] &= 0x7f;\n      const s = hexlify(vs);\n\n      if (result.s == null) {\n        result.s = s;\n      } else if (result.s !== s) {\n        logger.throwArgumentError(\"signature v mismatch _vs\", \"signature\", signature);\n      }\n    } // Use recid and v to populate each other\n\n\n    if (result.recoveryParam == null) {\n      if (result.v == null) {\n        logger.throwArgumentError(\"signature missing v and recoveryParam\", \"signature\", signature);\n      } else if (result.v === 0 || result.v === 1) {\n        result.recoveryParam = result.v;\n      } else {\n        result.recoveryParam = 1 - result.v % 2;\n      }\n    } else {\n      if (result.v == null) {\n        result.v = 27 + result.recoveryParam;\n      } else {\n        const recId = result.v === 0 || result.v === 1 ? result.v : 1 - result.v % 2;\n\n        if (result.recoveryParam !== recId) {\n          logger.throwArgumentError(\"signature recoveryParam mismatch v\", \"signature\", signature);\n        }\n      }\n    }\n\n    if (result.r == null || !isHexString(result.r)) {\n      logger.throwArgumentError(\"signature missing or invalid r\", \"signature\", signature);\n    } else {\n      result.r = hexZeroPad(result.r, 32);\n    }\n\n    if (result.s == null || !isHexString(result.s)) {\n      logger.throwArgumentError(\"signature missing or invalid s\", \"signature\", signature);\n    } else {\n      result.s = hexZeroPad(result.s, 32);\n    }\n\n    const vs = arrayify(result.s);\n\n    if (vs[0] >= 128) {\n      logger.throwArgumentError(\"signature s out of range\", \"signature\", signature);\n    }\n\n    if (result.recoveryParam) {\n      vs[0] |= 0x80;\n    }\n\n    const _vs = hexlify(vs);\n\n    if (result._vs) {\n      if (!isHexString(result._vs)) {\n        logger.throwArgumentError(\"signature invalid _vs\", \"signature\", signature);\n      }\n\n      result._vs = hexZeroPad(result._vs, 32);\n    } // Set or check the _vs\n\n\n    if (result._vs == null) {\n      result._vs = _vs;\n    } else if (result._vs !== _vs) {\n      logger.throwArgumentError(\"signature _vs mismatch v and s\", \"signature\", signature);\n    }\n  }\n\n  result.yParityAndS = result._vs;\n  result.compact = result.r + result.yParityAndS.substring(2);\n  return result;\n}\nexport function joinSignature(signature) {\n  signature = splitSignature(signature);\n  return hexlify(concat([signature.r, signature.s, signature.recoveryParam ? \"0x1c\" : \"0x1b\"]));\n}","map":{"version":3,"sources":["C:/Users/seins/Documents/GitHub/react-website-v1/node_modules/@ethersproject/bytes/lib.esm/index.js"],"names":["Logger","version","logger","isHexable","value","toHexString","addSlice","array","slice","args","Array","prototype","call","arguments","Uint8Array","apply","isBytesLike","isHexString","length","isBytes","isInteger","constructor","i","v","arrayify","options","checkSafeUint53","result","unshift","parseInt","String","push","allowMissingPrefix","substring","hex","hexPad","throwArgumentError","concat","items","objects","map","item","reduce","accum","offset","object","set","stripZeros","start","zeroPad","match","HexCharacters","hexlify","Math","floor","toString","toLowerCase","hexDataLength","data","hexDataSlice","endOffset","hexConcat","forEach","hexValue","trimmed","hexStripZeros","hexZeroPad","splitSignature","signature","r","s","_vs","recoveryParam","yParityAndS","compact","bytes","vs","recId","joinSignature"],"mappings":"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","sourcesContent":["\"use strict\";\r\nimport { Logger } from \"@ethersproject/logger\";\r\nimport { version } from \"./_version\";\r\nconst logger = new Logger(version);\r\n///////////////////////////////\r\nfunction isHexable(value) {\r\n    return !!(value.toHexString);\r\n}\r\nfunction addSlice(array) {\r\n    if (array.slice) {\r\n        return array;\r\n    }\r\n    array.slice = function () {\r\n        const args = Array.prototype.slice.call(arguments);\r\n        return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));\r\n    };\r\n    return array;\r\n}\r\nexport function isBytesLike(value) {\r\n    return ((isHexString(value) && !(value.length % 2)) || isBytes(value));\r\n}\r\nfunction isInteger(value) {\r\n    return (typeof (value) === \"number\" && value == value && (value % 1) === 0);\r\n}\r\nexport function isBytes(value) {\r\n    if (value == null) {\r\n        return false;\r\n    }\r\n    if (value.constructor === Uint8Array) {\r\n        return true;\r\n    }\r\n    if (typeof (value) === \"string\") {\r\n        return false;\r\n    }\r\n    if (!isInteger(value.length) || value.length < 0) {\r\n        return false;\r\n    }\r\n    for (let i = 0; i < value.length; i++) {\r\n        const v = value[i];\r\n        if (!isInteger(v) || v < 0 || v >= 256) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\nexport function arrayify(value, options) {\r\n    if (!options) {\r\n        options = {};\r\n    }\r\n    if (typeof (value) === \"number\") {\r\n        logger.checkSafeUint53(value, \"invalid arrayify value\");\r\n        const result = [];\r\n        while (value) {\r\n            result.unshift(value & 0xff);\r\n            value = parseInt(String(value / 256));\r\n        }\r\n        if (result.length === 0) {\r\n            result.push(0);\r\n        }\r\n        return addSlice(new Uint8Array(result));\r\n    }\r\n    if (options.allowMissingPrefix && typeof (value) === \"string\" && value.substring(0, 2) !== \"0x\") {\r\n        value = \"0x\" + value;\r\n    }\r\n    if (isHexable(value)) {\r\n        value = value.toHexString();\r\n    }\r\n    if (isHexString(value)) {\r\n        let hex = value.substring(2);\r\n        if (hex.length % 2) {\r\n            if (options.hexPad === \"left\") {\r\n                hex = \"0\" + hex;\r\n            }\r\n            else if (options.hexPad === \"right\") {\r\n                hex += \"0\";\r\n            }\r\n            else {\r\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\r\n            }\r\n        }\r\n        const result = [];\r\n        for (let i = 0; i < hex.length; i += 2) {\r\n            result.push(parseInt(hex.substring(i, i + 2), 16));\r\n        }\r\n        return addSlice(new Uint8Array(result));\r\n    }\r\n    if (isBytes(value)) {\r\n        return addSlice(new Uint8Array(value));\r\n    }\r\n    return logger.throwArgumentError(\"invalid arrayify value\", \"value\", value);\r\n}\r\nexport function concat(items) {\r\n    const objects = items.map(item => arrayify(item));\r\n    const length = objects.reduce((accum, item) => (accum + item.length), 0);\r\n    const result = new Uint8Array(length);\r\n    objects.reduce((offset, object) => {\r\n        result.set(object, offset);\r\n        return offset + object.length;\r\n    }, 0);\r\n    return addSlice(result);\r\n}\r\nexport function stripZeros(value) {\r\n    let result = arrayify(value);\r\n    if (result.length === 0) {\r\n        return result;\r\n    }\r\n    // Find the first non-zero entry\r\n    let start = 0;\r\n    while (start < result.length && result[start] === 0) {\r\n        start++;\r\n    }\r\n    // If we started with zeros, strip them\r\n    if (start) {\r\n        result = result.slice(start);\r\n    }\r\n    return result;\r\n}\r\nexport function zeroPad(value, length) {\r\n    value = arrayify(value);\r\n    if (value.length > length) {\r\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[0]);\r\n    }\r\n    const result = new Uint8Array(length);\r\n    result.set(value, length - value.length);\r\n    return addSlice(result);\r\n}\r\nexport function isHexString(value, length) {\r\n    if (typeof (value) !== \"string\" || !value.match(/^0x[0-9A-Fa-f]*$/)) {\r\n        return false;\r\n    }\r\n    if (length && value.length !== 2 + 2 * length) {\r\n        return false;\r\n    }\r\n    return true;\r\n}\r\nconst HexCharacters = \"0123456789abcdef\";\r\nexport function hexlify(value, options) {\r\n    if (!options) {\r\n        options = {};\r\n    }\r\n    if (typeof (value) === \"number\") {\r\n        logger.checkSafeUint53(value, \"invalid hexlify value\");\r\n        let hex = \"\";\r\n        while (value) {\r\n            hex = HexCharacters[value & 0xf] + hex;\r\n            value = Math.floor(value / 16);\r\n        }\r\n        if (hex.length) {\r\n            if (hex.length % 2) {\r\n                hex = \"0\" + hex;\r\n            }\r\n            return \"0x\" + hex;\r\n        }\r\n        return \"0x00\";\r\n    }\r\n    if (typeof (value) === \"bigint\") {\r\n        value = value.toString(16);\r\n        if (value.length % 2) {\r\n            return (\"0x0\" + value);\r\n        }\r\n        return \"0x\" + value;\r\n    }\r\n    if (options.allowMissingPrefix && typeof (value) === \"string\" && value.substring(0, 2) !== \"0x\") {\r\n        value = \"0x\" + value;\r\n    }\r\n    if (isHexable(value)) {\r\n        return value.toHexString();\r\n    }\r\n    if (isHexString(value)) {\r\n        if (value.length % 2) {\r\n            if (options.hexPad === \"left\") {\r\n                value = \"0x0\" + value.substring(2);\r\n            }\r\n            else if (options.hexPad === \"right\") {\r\n                value += \"0\";\r\n            }\r\n            else {\r\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\r\n            }\r\n        }\r\n        return value.toLowerCase();\r\n    }\r\n    if (isBytes(value)) {\r\n        let result = \"0x\";\r\n        for (let i = 0; i < value.length; i++) {\r\n            let v = value[i];\r\n            result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];\r\n        }\r\n        return result;\r\n    }\r\n    return logger.throwArgumentError(\"invalid hexlify value\", \"value\", value);\r\n}\r\n/*\r\nfunction unoddify(value: BytesLike | Hexable | number): BytesLike | Hexable | number {\r\n    if (typeof(value) === \"string\" && value.length % 2 && value.substring(0, 2) === \"0x\") {\r\n        return \"0x0\" + value.substring(2);\r\n    }\r\n    return value;\r\n}\r\n*/\r\nexport function hexDataLength(data) {\r\n    if (typeof (data) !== \"string\") {\r\n        data = hexlify(data);\r\n    }\r\n    else if (!isHexString(data) || (data.length % 2)) {\r\n        return null;\r\n    }\r\n    return (data.length - 2) / 2;\r\n}\r\nexport function hexDataSlice(data, offset, endOffset) {\r\n    if (typeof (data) !== \"string\") {\r\n        data = hexlify(data);\r\n    }\r\n    else if (!isHexString(data) || (data.length % 2)) {\r\n        logger.throwArgumentError(\"invalid hexData\", \"value\", data);\r\n    }\r\n    offset = 2 + 2 * offset;\r\n    if (endOffset != null) {\r\n        return \"0x\" + data.substring(offset, 2 + 2 * endOffset);\r\n    }\r\n    return \"0x\" + data.substring(offset);\r\n}\r\nexport function hexConcat(items) {\r\n    let result = \"0x\";\r\n    items.forEach((item) => {\r\n        result += hexlify(item).substring(2);\r\n    });\r\n    return result;\r\n}\r\nexport function hexValue(value) {\r\n    const trimmed = hexStripZeros(hexlify(value, { hexPad: \"left\" }));\r\n    if (trimmed === \"0x\") {\r\n        return \"0x0\";\r\n    }\r\n    return trimmed;\r\n}\r\nexport function hexStripZeros(value) {\r\n    if (typeof (value) !== \"string\") {\r\n        value = hexlify(value);\r\n    }\r\n    if (!isHexString(value)) {\r\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\r\n    }\r\n    value = value.substring(2);\r\n    let offset = 0;\r\n    while (offset < value.length && value[offset] === \"0\") {\r\n        offset++;\r\n    }\r\n    return \"0x\" + value.substring(offset);\r\n}\r\nexport function hexZeroPad(value, length) {\r\n    if (typeof (value) !== \"string\") {\r\n        value = hexlify(value);\r\n    }\r\n    else if (!isHexString(value)) {\r\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\r\n    }\r\n    if (value.length > 2 * length + 2) {\r\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[1]);\r\n    }\r\n    while (value.length < 2 * length + 2) {\r\n        value = \"0x0\" + value.substring(2);\r\n    }\r\n    return value;\r\n}\r\nexport function splitSignature(signature) {\r\n    const result = {\r\n        r: \"0x\",\r\n        s: \"0x\",\r\n        _vs: \"0x\",\r\n        recoveryParam: 0,\r\n        v: 0,\r\n        yParityAndS: \"0x\",\r\n        compact: \"0x\"\r\n    };\r\n    if (isBytesLike(signature)) {\r\n        let bytes = arrayify(signature);\r\n        // Get the r, s and v\r\n        if (bytes.length === 64) {\r\n            // EIP-2098; pull the v from the top bit of s and clear it\r\n            result.v = 27 + (bytes[32] >> 7);\r\n            bytes[32] &= 0x7f;\r\n            result.r = hexlify(bytes.slice(0, 32));\r\n            result.s = hexlify(bytes.slice(32, 64));\r\n        }\r\n        else if (bytes.length === 65) {\r\n            result.r = hexlify(bytes.slice(0, 32));\r\n            result.s = hexlify(bytes.slice(32, 64));\r\n            result.v = bytes[64];\r\n        }\r\n        else {\r\n            logger.throwArgumentError(\"invalid signature string\", \"signature\", signature);\r\n        }\r\n        // Allow a recid to be used as the v\r\n        if (result.v < 27) {\r\n            if (result.v === 0 || result.v === 1) {\r\n                result.v += 27;\r\n            }\r\n            else {\r\n                logger.throwArgumentError(\"signature invalid v byte\", \"signature\", signature);\r\n            }\r\n        }\r\n        // Compute recoveryParam from v\r\n        result.recoveryParam = 1 - (result.v % 2);\r\n        // Compute _vs from recoveryParam and s\r\n        if (result.recoveryParam) {\r\n            bytes[32] |= 0x80;\r\n        }\r\n        result._vs = hexlify(bytes.slice(32, 64));\r\n    }\r\n    else {\r\n        result.r = signature.r;\r\n        result.s = signature.s;\r\n        result.v = signature.v;\r\n        result.recoveryParam = signature.recoveryParam;\r\n        result._vs = signature._vs;\r\n        // If the _vs is available, use it to populate missing s, v and recoveryParam\r\n        // and verify non-missing s, v and recoveryParam\r\n        if (result._vs != null) {\r\n            const vs = zeroPad(arrayify(result._vs), 32);\r\n            result._vs = hexlify(vs);\r\n            // Set or check the recid\r\n            const recoveryParam = ((vs[0] >= 128) ? 1 : 0);\r\n            if (result.recoveryParam == null) {\r\n                result.recoveryParam = recoveryParam;\r\n            }\r\n            else if (result.recoveryParam !== recoveryParam) {\r\n                logger.throwArgumentError(\"signature recoveryParam mismatch _vs\", \"signature\", signature);\r\n            }\r\n            // Set or check the s\r\n            vs[0] &= 0x7f;\r\n            const s = hexlify(vs);\r\n            if (result.s == null) {\r\n                result.s = s;\r\n            }\r\n            else if (result.s !== s) {\r\n                logger.throwArgumentError(\"signature v mismatch _vs\", \"signature\", signature);\r\n            }\r\n        }\r\n        // Use recid and v to populate each other\r\n        if (result.recoveryParam == null) {\r\n            if (result.v == null) {\r\n                logger.throwArgumentError(\"signature missing v and recoveryParam\", \"signature\", signature);\r\n            }\r\n            else if (result.v === 0 || result.v === 1) {\r\n                result.recoveryParam = result.v;\r\n            }\r\n            else {\r\n                result.recoveryParam = 1 - (result.v % 2);\r\n            }\r\n        }\r\n        else {\r\n            if (result.v == null) {\r\n                result.v = 27 + result.recoveryParam;\r\n            }\r\n            else {\r\n                const recId = (result.v === 0 || result.v === 1) ? result.v : (1 - (result.v % 2));\r\n                if (result.recoveryParam !== recId) {\r\n                    logger.throwArgumentError(\"signature recoveryParam mismatch v\", \"signature\", signature);\r\n                }\r\n            }\r\n        }\r\n        if (result.r == null || !isHexString(result.r)) {\r\n            logger.throwArgumentError(\"signature missing or invalid r\", \"signature\", signature);\r\n        }\r\n        else {\r\n            result.r = hexZeroPad(result.r, 32);\r\n        }\r\n        if (result.s == null || !isHexString(result.s)) {\r\n            logger.throwArgumentError(\"signature missing or invalid s\", \"signature\", signature);\r\n        }\r\n        else {\r\n            result.s = hexZeroPad(result.s, 32);\r\n        }\r\n        const vs = arrayify(result.s);\r\n        if (vs[0] >= 128) {\r\n            logger.throwArgumentError(\"signature s out of range\", \"signature\", signature);\r\n        }\r\n        if (result.recoveryParam) {\r\n            vs[0] |= 0x80;\r\n        }\r\n        const _vs = hexlify(vs);\r\n        if (result._vs) {\r\n            if (!isHexString(result._vs)) {\r\n                logger.throwArgumentError(\"signature invalid _vs\", \"signature\", signature);\r\n            }\r\n            result._vs = hexZeroPad(result._vs, 32);\r\n        }\r\n        // Set or check the _vs\r\n        if (result._vs == null) {\r\n            result._vs = _vs;\r\n        }\r\n        else if (result._vs !== _vs) {\r\n            logger.throwArgumentError(\"signature _vs mismatch v and s\", \"signature\", signature);\r\n        }\r\n    }\r\n    result.yParityAndS = result._vs;\r\n    result.compact = result.r + result.yParityAndS.substring(2);\r\n    return result;\r\n}\r\nexport function joinSignature(signature) {\r\n    signature = splitSignature(signature);\r\n    return hexlify(concat([\r\n        signature.r,\r\n        signature.s,\r\n        (signature.recoveryParam ? \"0x1c\" : \"0x1b\")\r\n    ]));\r\n}\r\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"module"}