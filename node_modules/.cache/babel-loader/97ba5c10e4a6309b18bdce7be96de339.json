{"ast":null,"code":"\"use strict\"; // Copyright (c) 2018-2022 Coinbase, Inc. <https://www.coinbase.com/>\n// Licensed under the Apache License, version 2.0\n\nvar _defineProperty = require(\"C:\\\\Users\\\\seins\\\\Documents\\\\GitHub\\\\react-website-v1\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/defineProperty\");\n\nvar _classCallCheck = require(\"C:\\\\Users\\\\seins\\\\Documents\\\\GitHub\\\\react-website-v1\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:\\\\Users\\\\seins\\\\Documents\\\\GitHub\\\\react-website-v1\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.WalletSDKConnection = void 0;\n\nvar rxjs_1 = require(\"rxjs\");\n\nvar operators_1 = require(\"rxjs/operators\");\n\nvar Session_1 = require(\"../relay/Session\");\n\nvar types_1 = require(\"../types\");\n\nvar ClientMessage_1 = require(\"./ClientMessage\");\n\nvar DiagnosticLogger_1 = require(\"./DiagnosticLogger\");\n\nvar RxWebSocket_1 = require(\"./RxWebSocket\");\n\nvar ServerMessage_1 = require(\"./ServerMessage\");\n\nvar HEARTBEAT_INTERVAL = 10000;\nvar REQUEST_TIMEOUT = 60000;\n/**\n * Coinbase Wallet Connection\n */\n\nvar WalletSDKConnection = /*#__PURE__*/function () {\n  /**\n   * Constructor\n   * @param sessionId Session ID\n   * @param sessionKey Session Key\n   * @param linkAPIUrl Coinbase Wallet link server URL\n   * @param [WebSocketClass] Custom WebSocket implementation\n   */\n  function WalletSDKConnection(sessionId, sessionKey, linkAPIUrl, diagnostic) {\n    var _this = this;\n\n    var WebSocketClass = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : WebSocket;\n\n    _classCallCheck(this, WalletSDKConnection);\n\n    this.sessionId = sessionId;\n    this.sessionKey = sessionKey;\n    this.diagnostic = diagnostic;\n    this.subscriptions = new rxjs_1.Subscription();\n    this.destroyed = false;\n    this.lastHeartbeatResponse = 0;\n    this.nextReqId = (0, types_1.IntNumber)(1);\n    this.connectedSubject = new rxjs_1.BehaviorSubject(false);\n    this.linkedSubject = new rxjs_1.BehaviorSubject(false);\n    this.sessionConfigSubject = new rxjs_1.ReplaySubject(1);\n    var ws = new RxWebSocket_1.RxWebSocket(linkAPIUrl + \"/rpc\", WebSocketClass);\n    this.ws = ws; // attempt to reconnect every 5 seconds when disconnected\n\n    this.subscriptions.add(ws.connectionState$.pipe((0, operators_1.tap)(function (state) {\n      var _a;\n\n      return (_a = _this.diagnostic) === null || _a === void 0 ? void 0 : _a.log(DiagnosticLogger_1.EVENTS.CONNECTED_STATE_CHANGE, {\n        state: state,\n        sessionIdHash: Session_1.Session.hash(sessionId)\n      });\n    }), // ignore initial DISCONNECTED state\n    (0, operators_1.skip)(1), // if DISCONNECTED and not destroyed\n    (0, operators_1.filter)(function (cs) {\n      return cs === RxWebSocket_1.ConnectionState.DISCONNECTED && !_this.destroyed;\n    }), // wait 5 seconds\n    (0, operators_1.delay)(5000), // check whether it's destroyed again\n    (0, operators_1.filter)(function (_) {\n      return !_this.destroyed;\n    }), // reconnect\n    (0, operators_1.flatMap)(function (_) {\n      return ws.connect();\n    }), (0, operators_1.retry)()).subscribe()); // perform authentication upon connection\n\n    this.subscriptions.add(ws.connectionState$.pipe( // ignore initial DISCONNECTED and CONNECTING states\n    (0, operators_1.skip)(2), (0, operators_1.switchMap)(function (cs) {\n      return (0, rxjs_1.iif)(function () {\n        return cs === RxWebSocket_1.ConnectionState.CONNECTED;\n      }, // if CONNECTED, authenticate, and then check link status\n      _this.authenticate().pipe((0, operators_1.tap)(function (_) {\n        return _this.sendIsLinked();\n      }), (0, operators_1.tap)(function (_) {\n        return _this.sendGetSessionConfig();\n      }), (0, operators_1.map)(function (_) {\n        return true;\n      })), // if not CONNECTED, emit false immediately\n      (0, rxjs_1.of)(false));\n    }), (0, operators_1.distinctUntilChanged)(), (0, operators_1.catchError)(function (_) {\n      return (0, rxjs_1.of)(false);\n    })).subscribe(function (connected) {\n      return _this.connectedSubject.next(connected);\n    })); // send heartbeat every n seconds while connected\n\n    this.subscriptions.add(ws.connectionState$.pipe( // ignore initial DISCONNECTED state\n    (0, operators_1.skip)(1), (0, operators_1.switchMap)(function (cs) {\n      return (0, rxjs_1.iif)(function () {\n        return cs === RxWebSocket_1.ConnectionState.CONNECTED;\n      }, // if CONNECTED, start the heartbeat timer\n      (0, rxjs_1.timer)(0, HEARTBEAT_INTERVAL));\n    })).subscribe(function (i) {\n      return (// first timer event updates lastHeartbeat timestamp\n        // subsequent calls send heartbeat message\n        i === 0 ? _this.updateLastHeartbeat() : _this.heartbeat()\n      );\n    })); // handle server's heartbeat responses\n\n    this.subscriptions.add(ws.incomingData$.pipe((0, operators_1.filter)(function (m) {\n      return m === \"h\";\n    })).subscribe(function (_) {\n      return _this.updateLastHeartbeat();\n    })); // handle link status updates\n\n    this.subscriptions.add(ws.incomingJSONData$.pipe((0, operators_1.filter)(function (m) {\n      return [\"IsLinkedOK\", \"Linked\"].includes(m.type);\n    })).subscribe(function (m) {\n      var _a;\n\n      var msg = m;\n      (_a = _this.diagnostic) === null || _a === void 0 ? void 0 : _a.log(DiagnosticLogger_1.EVENTS.LINKED, {\n        sessionIdHash: Session_1.Session.hash(sessionId),\n        linked: msg.linked,\n        type: m.type,\n        onlineGuests: msg.onlineGuests\n      });\n\n      _this.linkedSubject.next(msg.linked || msg.onlineGuests > 0);\n    })); // handle session config updates\n\n    this.subscriptions.add(ws.incomingJSONData$.pipe((0, operators_1.filter)(function (m) {\n      return [\"GetSessionConfigOK\", \"SessionConfigUpdated\"].includes(m.type);\n    })).subscribe(function (m) {\n      var _a;\n\n      var msg = m;\n      (_a = _this.diagnostic) === null || _a === void 0 ? void 0 : _a.log(DiagnosticLogger_1.EVENTS.SESSION_CONFIG_RECEIVED, {\n        sessionIdHash: Session_1.Session.hash(sessionId),\n        metadata_keys: msg && msg.metadata ? Object.keys(msg.metadata) : undefined\n      });\n\n      _this.sessionConfigSubject.next({\n        webhookId: msg.webhookId,\n        webhookUrl: msg.webhookUrl,\n        metadata: msg.metadata\n      });\n    }));\n  }\n  /**\n   * Make a connection to the server\n   */\n\n\n  _createClass(WalletSDKConnection, [{\n    key: \"connect\",\n    value: function connect() {\n      var _a;\n\n      if (this.destroyed) {\n        throw new Error(\"instance is destroyed\");\n      }\n\n      (_a = this.diagnostic) === null || _a === void 0 ? void 0 : _a.log(DiagnosticLogger_1.EVENTS.STARTED_CONNECTING, {\n        sessionIdHash: Session_1.Session.hash(this.sessionId)\n      });\n      this.ws.connect().subscribe();\n    }\n    /**\n     * Terminate connection, and mark as destroyed. To reconnect, create a new\n     * instance of WalletSDKConnection\n     */\n\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      var _a;\n\n      this.subscriptions.unsubscribe();\n      this.ws.disconnect();\n      (_a = this.diagnostic) === null || _a === void 0 ? void 0 : _a.log(DiagnosticLogger_1.EVENTS.DISCONNECTED, {\n        sessionIdHash: Session_1.Session.hash(this.sessionId)\n      });\n      this.destroyed = true;\n    }\n  }, {\n    key: \"isDestroyed\",\n    get: function get() {\n      return this.destroyed;\n    }\n    /**\n     * Emit true if connected and authenticated, else false\n     * @returns an Observable\n     */\n\n  }, {\n    key: \"connected$\",\n    get: function get() {\n      return this.connectedSubject.asObservable();\n    }\n    /**\n     * Emit once connected\n     * @returns an Observable\n     */\n\n  }, {\n    key: \"onceConnected$\",\n    get: function get() {\n      return this.connected$.pipe((0, operators_1.filter)(function (v) {\n        return v;\n      }), (0, operators_1.take)(1), (0, operators_1.map)(function () {\n        return void 0;\n      }));\n    }\n    /**\n     * Emit true if linked (a guest has joined before)\n     * @returns an Observable\n     */\n\n  }, {\n    key: \"linked$\",\n    get: function get() {\n      return this.linkedSubject.asObservable();\n    }\n    /**\n     * Emit once when linked\n     * @returns an Observable\n     */\n\n  }, {\n    key: \"onceLinked$\",\n    get: function get() {\n      return this.linked$.pipe((0, operators_1.filter)(function (v) {\n        return v;\n      }), (0, operators_1.take)(1), (0, operators_1.map)(function () {\n        return void 0;\n      }));\n    }\n    /**\n     * Emit current session config if available, and subsequent updates\n     * @returns an Observable for the session config\n     */\n\n  }, {\n    key: \"sessionConfig$\",\n    get: function get() {\n      return this.sessionConfigSubject.asObservable();\n    }\n    /**\n     * Emit incoming Event messages\n     * @returns an Observable for the messages\n     */\n\n  }, {\n    key: \"incomingEvent$\",\n    get: function get() {\n      return this.ws.incomingJSONData$.pipe((0, operators_1.filter)(function (m) {\n        if (m.type !== \"Event\") {\n          return false;\n        }\n\n        var sme = m;\n        return typeof sme.sessionId === \"string\" && typeof sme.eventId === \"string\" && typeof sme.event === \"string\" && typeof sme.data === \"string\";\n      }), (0, operators_1.map)(function (m) {\n        return m;\n      }));\n    }\n    /**\n     * Set session metadata in SessionConfig object\n     * @param key\n     * @param value\n     * @returns an Observable that completes when successful\n     */\n\n  }, {\n    key: \"setSessionMetadata\",\n    value: function setSessionMetadata(key, value) {\n      var _this2 = this;\n\n      var message = (0, ClientMessage_1.ClientMessageSetSessionConfig)({\n        id: (0, types_1.IntNumber)(this.nextReqId++),\n        sessionId: this.sessionId,\n        metadata: _defineProperty({}, key, value)\n      });\n      return this.onceConnected$.pipe((0, operators_1.flatMap)(function (_) {\n        return _this2.makeRequest(message);\n      }), (0, operators_1.map)(function (res) {\n        if ((0, ServerMessage_1.isServerMessageFail)(res)) {\n          throw new Error(res.error || \"failed to set session metadata\");\n        }\n      }));\n    }\n    /**\n     * Publish an event and emit event ID when successful\n     * @param event event name\n     * @param data event data\n     * @param callWebhook whether the webhook should be invoked\n     * @returns an Observable that emits event ID when successful\n     */\n\n  }, {\n    key: \"publishEvent\",\n    value: function publishEvent(event, data) {\n      var _this3 = this;\n\n      var callWebhook = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      var message = (0, ClientMessage_1.ClientMessagePublishEvent)({\n        id: (0, types_1.IntNumber)(this.nextReqId++),\n        sessionId: this.sessionId,\n        event: event,\n        data: data,\n        callWebhook: callWebhook\n      });\n      return this.onceLinked$.pipe((0, operators_1.flatMap)(function (_) {\n        return _this3.makeRequest(message);\n      }), (0, operators_1.map)(function (res) {\n        if ((0, ServerMessage_1.isServerMessageFail)(res)) {\n          throw new Error(res.error || \"failed to publish event\");\n        }\n\n        return res.eventId;\n      }));\n    }\n  }, {\n    key: \"sendData\",\n    value: function sendData(message) {\n      this.ws.sendData(JSON.stringify(message));\n    }\n  }, {\n    key: \"updateLastHeartbeat\",\n    value: function updateLastHeartbeat() {\n      this.lastHeartbeatResponse = Date.now();\n    }\n  }, {\n    key: \"heartbeat\",\n    value: function heartbeat() {\n      if (Date.now() - this.lastHeartbeatResponse > HEARTBEAT_INTERVAL * 2) {\n        this.ws.disconnect();\n        return;\n      }\n\n      try {\n        this.ws.sendData(\"h\");\n      } catch (_a) {}\n    }\n  }, {\n    key: \"makeRequest\",\n    value: function makeRequest(message) {\n      var timeout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : REQUEST_TIMEOUT;\n      var reqId = message.id;\n\n      try {\n        this.sendData(message);\n      } catch (err) {\n        return (0, rxjs_1.throwError)(err);\n      } // await server message with corresponding id\n\n\n      return this.ws.incomingJSONData$.pipe((0, operators_1.timeoutWith)(timeout, (0, rxjs_1.throwError)(new Error(\"request \".concat(reqId, \" timed out\")))), (0, operators_1.filter)(function (m) {\n        return m.id === reqId;\n      }), (0, operators_1.take)(1));\n    }\n  }, {\n    key: \"authenticate\",\n    value: function authenticate() {\n      var msg = (0, ClientMessage_1.ClientMessageHostSession)({\n        id: (0, types_1.IntNumber)(this.nextReqId++),\n        sessionId: this.sessionId,\n        sessionKey: this.sessionKey\n      });\n      return this.makeRequest(msg).pipe((0, operators_1.map)(function (res) {\n        if ((0, ServerMessage_1.isServerMessageFail)(res)) {\n          throw new Error(res.error || \"failed to authentcate\");\n        }\n      }));\n    }\n  }, {\n    key: \"sendIsLinked\",\n    value: function sendIsLinked() {\n      var msg = (0, ClientMessage_1.ClientMessageIsLinked)({\n        id: (0, types_1.IntNumber)(this.nextReqId++),\n        sessionId: this.sessionId\n      });\n      this.sendData(msg);\n    }\n  }, {\n    key: \"sendGetSessionConfig\",\n    value: function sendGetSessionConfig() {\n      var msg = (0, ClientMessage_1.ClientMessageGetSessionConfig)({\n        id: (0, types_1.IntNumber)(this.nextReqId++),\n        sessionId: this.sessionId\n      });\n      this.sendData(msg);\n    }\n  }]);\n\n  return WalletSDKConnection;\n}();\n\nexports.WalletSDKConnection = WalletSDKConnection;","map":{"version":3,"sources":["C:/Users/seins/Documents/GitHub/react-website-v1/node_modules/@coinbase/wallet-sdk/dist/connection/WalletSDKConnection.js"],"names":["Object","defineProperty","exports","value","WalletSDKConnection","rxjs_1","require","operators_1","Session_1","types_1","ClientMessage_1","DiagnosticLogger_1","RxWebSocket_1","ServerMessage_1","HEARTBEAT_INTERVAL","REQUEST_TIMEOUT","sessionId","sessionKey","linkAPIUrl","diagnostic","WebSocketClass","WebSocket","subscriptions","Subscription","destroyed","lastHeartbeatResponse","nextReqId","IntNumber","connectedSubject","BehaviorSubject","linkedSubject","sessionConfigSubject","ReplaySubject","ws","RxWebSocket","add","connectionState$","pipe","tap","state","_a","log","EVENTS","CONNECTED_STATE_CHANGE","sessionIdHash","Session","hash","skip","filter","cs","ConnectionState","DISCONNECTED","delay","_","flatMap","connect","retry","subscribe","switchMap","iif","CONNECTED","authenticate","sendIsLinked","sendGetSessionConfig","map","of","distinctUntilChanged","catchError","connected","next","timer","i","updateLastHeartbeat","heartbeat","incomingData$","m","incomingJSONData$","includes","type","msg","LINKED","linked","onlineGuests","SESSION_CONFIG_RECEIVED","metadata_keys","metadata","keys","undefined","webhookId","webhookUrl","Error","STARTED_CONNECTING","unsubscribe","disconnect","asObservable","connected$","v","take","linked$","sme","eventId","event","data","key","message","ClientMessageSetSessionConfig","id","onceConnected$","makeRequest","res","isServerMessageFail","error","callWebhook","ClientMessagePublishEvent","onceLinked$","sendData","JSON","stringify","Date","now","timeout","reqId","err","throwError","timeoutWith","ClientMessageHostSession","ClientMessageIsLinked","ClientMessageGetSessionConfig"],"mappings":"AAAA,a,CACA;AACA;;;;;;;;AACAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;AACAD,OAAO,CAACE,mBAAR,GAA8B,KAAK,CAAnC;;AACA,IAAMC,MAAM,GAAGC,OAAO,CAAC,MAAD,CAAtB;;AACA,IAAMC,WAAW,GAAGD,OAAO,CAAC,gBAAD,CAA3B;;AACA,IAAME,SAAS,GAAGF,OAAO,CAAC,kBAAD,CAAzB;;AACA,IAAMG,OAAO,GAAGH,OAAO,CAAC,UAAD,CAAvB;;AACA,IAAMI,eAAe,GAAGJ,OAAO,CAAC,iBAAD,CAA/B;;AACA,IAAMK,kBAAkB,GAAGL,OAAO,CAAC,oBAAD,CAAlC;;AACA,IAAMM,aAAa,GAAGN,OAAO,CAAC,eAAD,CAA7B;;AACA,IAAMO,eAAe,GAAGP,OAAO,CAAC,iBAAD,CAA/B;;AACA,IAAMQ,kBAAkB,GAAG,KAA3B;AACA,IAAMC,eAAe,GAAG,KAAxB;AACA;AACA;AACA;;IACMX,mB;AACF;AACJ;AACA;AACA;AACA;AACA;AACA;AACI,+BAAYY,SAAZ,EAAuBC,UAAvB,EAAmCC,UAAnC,EAA+CC,UAA/C,EAAuF;AAAA;;AAAA,QAA5BC,cAA4B,uEAAXC,SAAW;;AAAA;;AACnF,SAAKL,SAAL,GAAiBA,SAAjB;AACA,SAAKC,UAAL,GAAkBA,UAAlB;AACA,SAAKE,UAAL,GAAkBA,UAAlB;AACA,SAAKG,aAAL,GAAqB,IAAIjB,MAAM,CAACkB,YAAX,EAArB;AACA,SAAKC,SAAL,GAAiB,KAAjB;AACA,SAAKC,qBAAL,GAA6B,CAA7B;AACA,SAAKC,SAAL,GAAiB,CAAC,GAAGjB,OAAO,CAACkB,SAAZ,EAAuB,CAAvB,CAAjB;AACA,SAAKC,gBAAL,GAAwB,IAAIvB,MAAM,CAACwB,eAAX,CAA2B,KAA3B,CAAxB;AACA,SAAKC,aAAL,GAAqB,IAAIzB,MAAM,CAACwB,eAAX,CAA2B,KAA3B,CAArB;AACA,SAAKE,oBAAL,GAA4B,IAAI1B,MAAM,CAAC2B,aAAX,CAAyB,CAAzB,CAA5B;AACA,QAAMC,EAAE,GAAG,IAAIrB,aAAa,CAACsB,WAAlB,CAA8BhB,UAAU,GAAG,MAA3C,EAAmDE,cAAnD,CAAX;AACA,SAAKa,EAAL,GAAUA,EAAV,CAZmF,CAanF;;AACA,SAAKX,aAAL,CAAmBa,GAAnB,CAAuBF,EAAE,CAACG,gBAAH,CAClBC,IADkB,CACb,CAAC,GAAG9B,WAAW,CAAC+B,GAAhB,EAAqB,UAAAC,KAAK,EAAI;AACpC,UAAIC,EAAJ;;AACA,aAAO,CAACA,EAAE,GAAG,KAAI,CAACrB,UAAX,MAA2B,IAA3B,IAAmCqB,EAAE,KAAK,KAAK,CAA/C,GAAmD,KAAK,CAAxD,GAA4DA,EAAE,CAACC,GAAH,CAAO9B,kBAAkB,CAAC+B,MAAnB,CAA0BC,sBAAjC,EAAyD;AACxHJ,QAAAA,KAAK,EAALA,KADwH;AAExHK,QAAAA,aAAa,EAAEpC,SAAS,CAACqC,OAAV,CAAkBC,IAAlB,CAAuB9B,SAAvB;AAFyG,OAAzD,CAAnE;AAIH,KANS,CADa,EAQvB;AACA,KAAC,GAAGT,WAAW,CAACwC,IAAhB,EAAsB,CAAtB,CATuB,EAUvB;AACA,KAAC,GAAGxC,WAAW,CAACyC,MAAhB,EAAwB,UAAAC,EAAE;AAAA,aAAIA,EAAE,KAAKrC,aAAa,CAACsC,eAAd,CAA8BC,YAArC,IAAqD,CAAC,KAAI,CAAC3B,SAA/D;AAAA,KAA1B,CAXuB,EAYvB;AACA,KAAC,GAAGjB,WAAW,CAAC6C,KAAhB,EAAuB,IAAvB,CAbuB,EAcvB;AACA,KAAC,GAAG7C,WAAW,CAACyC,MAAhB,EAAwB,UAAAK,CAAC;AAAA,aAAI,CAAC,KAAI,CAAC7B,SAAV;AAAA,KAAzB,CAfuB,EAgBvB;AACA,KAAC,GAAGjB,WAAW,CAAC+C,OAAhB,EAAyB,UAAAD,CAAC;AAAA,aAAIpB,EAAE,CAACsB,OAAH,EAAJ;AAAA,KAA1B,CAjBuB,EAiBsB,CAAC,GAAGhD,WAAW,CAACiD,KAAhB,GAjBtB,EAkBlBC,SAlBkB,EAAvB,EAdmF,CAiCnF;;AACA,SAAKnC,aAAL,CAAmBa,GAAnB,CAAuBF,EAAE,CAACG,gBAAH,CAClBC,IADkB,EAEvB;AACA,KAAC,GAAG9B,WAAW,CAACwC,IAAhB,EAAsB,CAAtB,CAHuB,EAGG,CAAC,GAAGxC,WAAW,CAACmD,SAAhB,EAA2B,UAAAT,EAAE;AAAA,aAAI,CAAC,GAAG5C,MAAM,CAACsD,GAAX,EAAgB;AAAA,eAAMV,EAAE,KAAKrC,aAAa,CAACsC,eAAd,CAA8BU,SAA3C;AAAA,OAAhB,EAC3D;AACA,MAAA,KAAI,CAACC,YAAL,GAAoBxB,IAApB,CAAyB,CAAC,GAAG9B,WAAW,CAAC+B,GAAhB,EAAqB,UAAAe,CAAC;AAAA,eAAI,KAAI,CAACS,YAAL,EAAJ;AAAA,OAAtB,CAAzB,EAAyE,CAAC,GAAGvD,WAAW,CAAC+B,GAAhB,EAAqB,UAAAe,CAAC;AAAA,eAAI,KAAI,CAACU,oBAAL,EAAJ;AAAA,OAAtB,CAAzE,EAAiI,CAAC,GAAGxD,WAAW,CAACyD,GAAhB,EAAqB,UAAAX,CAAC;AAAA,eAAI,IAAJ;AAAA,OAAtB,CAAjI,CAF2D,EAG3D;AACA,OAAC,GAAGhD,MAAM,CAAC4D,EAAX,EAAe,KAAf,CAJ2D,CAAJ;AAAA,KAA7B,CAHH,EAOE,CAAC,GAAG1D,WAAW,CAAC2D,oBAAhB,GAPF,EAO2C,CAAC,GAAG3D,WAAW,CAAC4D,UAAhB,EAA4B,UAAAd,CAAC;AAAA,aAAI,CAAC,GAAGhD,MAAM,CAAC4D,EAAX,EAAe,KAAf,CAAJ;AAAA,KAA7B,CAP3C,EAQlBR,SARkB,CAQR,UAAAW,SAAS;AAAA,aAAI,KAAI,CAACxC,gBAAL,CAAsByC,IAAtB,CAA2BD,SAA3B,CAAJ;AAAA,KARD,CAAvB,EAlCmF,CA2CnF;;AACA,SAAK9C,aAAL,CAAmBa,GAAnB,CAAuBF,EAAE,CAACG,gBAAH,CAClBC,IADkB,EAEvB;AACA,KAAC,GAAG9B,WAAW,CAACwC,IAAhB,EAAsB,CAAtB,CAHuB,EAGG,CAAC,GAAGxC,WAAW,CAACmD,SAAhB,EAA2B,UAAAT,EAAE;AAAA,aAAI,CAAC,GAAG5C,MAAM,CAACsD,GAAX,EAAgB;AAAA,eAAMV,EAAE,KAAKrC,aAAa,CAACsC,eAAd,CAA8BU,SAA3C;AAAA,OAAhB,EAC3D;AACA,OAAC,GAAGvD,MAAM,CAACiE,KAAX,EAAkB,CAAlB,EAAqBxD,kBAArB,CAF2D,CAAJ;AAAA,KAA7B,CAHH,EAMlB2C,SANkB,CAMR,UAAAc,CAAC;AAAA,aAChB;AACA;AACAA,QAAAA,CAAC,KAAK,CAAN,GAAU,KAAI,CAACC,mBAAL,EAAV,GAAuC,KAAI,CAACC,SAAL;AAHvB;AAAA,KANO,CAAvB,EA5CmF,CAsDnF;;AACA,SAAKnD,aAAL,CAAmBa,GAAnB,CAAuBF,EAAE,CAACyC,aAAH,CAClBrC,IADkB,CACb,CAAC,GAAG9B,WAAW,CAACyC,MAAhB,EAAwB,UAAA2B,CAAC;AAAA,aAAIA,CAAC,KAAK,GAAV;AAAA,KAAzB,CADa,EAElBlB,SAFkB,CAER,UAAAJ,CAAC;AAAA,aAAI,KAAI,CAACmB,mBAAL,EAAJ;AAAA,KAFO,CAAvB,EAvDmF,CA0DnF;;AACA,SAAKlD,aAAL,CAAmBa,GAAnB,CAAuBF,EAAE,CAAC2C,iBAAH,CAClBvC,IADkB,CACb,CAAC,GAAG9B,WAAW,CAACyC,MAAhB,EAAwB,UAAA2B,CAAC;AAAA,aAAI,CAAC,YAAD,EAAe,QAAf,EAAyBE,QAAzB,CAAkCF,CAAC,CAACG,IAApC,CAAJ;AAAA,KAAzB,CADa,EAElBrB,SAFkB,CAER,UAAAkB,CAAC,EAAI;AAChB,UAAInC,EAAJ;;AACA,UAAMuC,GAAG,GAAGJ,CAAZ;AACA,OAACnC,EAAE,GAAG,KAAI,CAACrB,UAAX,MAA2B,IAA3B,IAAmCqB,EAAE,KAAK,KAAK,CAA/C,GAAmD,KAAK,CAAxD,GAA4DA,EAAE,CAACC,GAAH,CAAO9B,kBAAkB,CAAC+B,MAAnB,CAA0BsC,MAAjC,EAAyC;AACjGpC,QAAAA,aAAa,EAAEpC,SAAS,CAACqC,OAAV,CAAkBC,IAAlB,CAAuB9B,SAAvB,CADkF;AAEjGiE,QAAAA,MAAM,EAAEF,GAAG,CAACE,MAFqF;AAGjGH,QAAAA,IAAI,EAAEH,CAAC,CAACG,IAHyF;AAIjGI,QAAAA,YAAY,EAAEH,GAAG,CAACG;AAJ+E,OAAzC,CAA5D;;AAMA,MAAA,KAAI,CAACpD,aAAL,CAAmBuC,IAAnB,CAAwBU,GAAG,CAACE,MAAJ,IAAcF,GAAG,CAACG,YAAJ,GAAmB,CAAzD;AACH,KAZsB,CAAvB,EA3DmF,CAwEnF;;AACA,SAAK5D,aAAL,CAAmBa,GAAnB,CAAuBF,EAAE,CAAC2C,iBAAH,CAClBvC,IADkB,CACb,CAAC,GAAG9B,WAAW,CAACyC,MAAhB,EAAwB,UAAA2B,CAAC;AAAA,aAAI,CAAC,oBAAD,EAAuB,sBAAvB,EAA+CE,QAA/C,CAAwDF,CAAC,CAACG,IAA1D,CAAJ;AAAA,KAAzB,CADa,EAElBrB,SAFkB,CAER,UAAAkB,CAAC,EAAI;AAChB,UAAInC,EAAJ;;AACA,UAAMuC,GAAG,GAAGJ,CAAZ;AACA,OAACnC,EAAE,GAAG,KAAI,CAACrB,UAAX,MAA2B,IAA3B,IAAmCqB,EAAE,KAAK,KAAK,CAA/C,GAAmD,KAAK,CAAxD,GAA4DA,EAAE,CAACC,GAAH,CAAO9B,kBAAkB,CAAC+B,MAAnB,CAA0ByC,uBAAjC,EAA0D;AAClHvC,QAAAA,aAAa,EAAEpC,SAAS,CAACqC,OAAV,CAAkBC,IAAlB,CAAuB9B,SAAvB,CADmG;AAElHoE,QAAAA,aAAa,EAAEL,GAAG,IAAIA,GAAG,CAACM,QAAX,GAAsBrF,MAAM,CAACsF,IAAP,CAAYP,GAAG,CAACM,QAAhB,CAAtB,GAAkDE;AAFiD,OAA1D,CAA5D;;AAIA,MAAA,KAAI,CAACxD,oBAAL,CAA0BsC,IAA1B,CAA+B;AAC3BmB,QAAAA,SAAS,EAAET,GAAG,CAACS,SADY;AAE3BC,QAAAA,UAAU,EAAEV,GAAG,CAACU,UAFW;AAG3BJ,QAAAA,QAAQ,EAAEN,GAAG,CAACM;AAHa,OAA/B;AAKH,KAdsB,CAAvB;AAeH;AACD;AACJ;AACA;;;;;WACI,mBAAU;AACN,UAAI7C,EAAJ;;AACA,UAAI,KAAKhB,SAAT,EAAoB;AAChB,cAAM,IAAIkE,KAAJ,CAAU,uBAAV,CAAN;AACH;;AACD,OAAClD,EAAE,GAAG,KAAKrB,UAAX,MAA2B,IAA3B,IAAmCqB,EAAE,KAAK,KAAK,CAA/C,GAAmD,KAAK,CAAxD,GAA4DA,EAAE,CAACC,GAAH,CAAO9B,kBAAkB,CAAC+B,MAAnB,CAA0BiD,kBAAjC,EAAqD;AAC7G/C,QAAAA,aAAa,EAAEpC,SAAS,CAACqC,OAAV,CAAkBC,IAAlB,CAAuB,KAAK9B,SAA5B;AAD8F,OAArD,CAA5D;AAGA,WAAKiB,EAAL,CAAQsB,OAAR,GAAkBE,SAAlB;AACH;AACD;AACJ;AACA;AACA;;;;WACI,mBAAU;AACN,UAAIjB,EAAJ;;AACA,WAAKlB,aAAL,CAAmBsE,WAAnB;AACA,WAAK3D,EAAL,CAAQ4D,UAAR;AACA,OAACrD,EAAE,GAAG,KAAKrB,UAAX,MAA2B,IAA3B,IAAmCqB,EAAE,KAAK,KAAK,CAA/C,GAAmD,KAAK,CAAxD,GAA4DA,EAAE,CAACC,GAAH,CAAO9B,kBAAkB,CAAC+B,MAAnB,CAA0BS,YAAjC,EAA+C;AACvGP,QAAAA,aAAa,EAAEpC,SAAS,CAACqC,OAAV,CAAkBC,IAAlB,CAAuB,KAAK9B,SAA5B;AADwF,OAA/C,CAA5D;AAGA,WAAKQ,SAAL,GAAiB,IAAjB;AACH;;;SACD,eAAkB;AACd,aAAO,KAAKA,SAAZ;AACH;AACD;AACJ;AACA;AACA;;;;SACI,eAAiB;AACb,aAAO,KAAKI,gBAAL,CAAsBkE,YAAtB,EAAP;AACH;AACD;AACJ;AACA;AACA;;;;SACI,eAAqB;AACjB,aAAO,KAAKC,UAAL,CAAgB1D,IAAhB,CAAqB,CAAC,GAAG9B,WAAW,CAACyC,MAAhB,EAAwB,UAAAgD,CAAC;AAAA,eAAIA,CAAJ;AAAA,OAAzB,CAArB,EAAsD,CAAC,GAAGzF,WAAW,CAAC0F,IAAhB,EAAsB,CAAtB,CAAtD,EAAgF,CAAC,GAAG1F,WAAW,CAACyD,GAAhB,EAAqB;AAAA,eAAM,KAAK,CAAX;AAAA,OAArB,CAAhF,CAAP;AACH;AACD;AACJ;AACA;AACA;;;;SACI,eAAc;AACV,aAAO,KAAKlC,aAAL,CAAmBgE,YAAnB,EAAP;AACH;AACD;AACJ;AACA;AACA;;;;SACI,eAAkB;AACd,aAAO,KAAKI,OAAL,CAAa7D,IAAb,CAAkB,CAAC,GAAG9B,WAAW,CAACyC,MAAhB,EAAwB,UAAAgD,CAAC;AAAA,eAAIA,CAAJ;AAAA,OAAzB,CAAlB,EAAmD,CAAC,GAAGzF,WAAW,CAAC0F,IAAhB,EAAsB,CAAtB,CAAnD,EAA6E,CAAC,GAAG1F,WAAW,CAACyD,GAAhB,EAAqB;AAAA,eAAM,KAAK,CAAX;AAAA,OAArB,CAA7E,CAAP;AACH;AACD;AACJ;AACA;AACA;;;;SACI,eAAqB;AACjB,aAAO,KAAKjC,oBAAL,CAA0B+D,YAA1B,EAAP;AACH;AACD;AACJ;AACA;AACA;;;;SACI,eAAqB;AACjB,aAAO,KAAK7D,EAAL,CAAQ2C,iBAAR,CAA0BvC,IAA1B,CAA+B,CAAC,GAAG9B,WAAW,CAACyC,MAAhB,EAAwB,UAAA2B,CAAC,EAAI;AAC/D,YAAIA,CAAC,CAACG,IAAF,KAAW,OAAf,EAAwB;AACpB,iBAAO,KAAP;AACH;;AACD,YAAMqB,GAAG,GAAGxB,CAAZ;AACA,eAAQ,OAAOwB,GAAG,CAACnF,SAAX,KAAyB,QAAzB,IACJ,OAAOmF,GAAG,CAACC,OAAX,KAAuB,QADnB,IAEJ,OAAOD,GAAG,CAACE,KAAX,KAAqB,QAFjB,IAGJ,OAAOF,GAAG,CAACG,IAAX,KAAoB,QAHxB;AAIH,OATqC,CAA/B,EASH,CAAC,GAAG/F,WAAW,CAACyD,GAAhB,EAAqB,UAAAW,CAAC;AAAA,eAAIA,CAAJ;AAAA,OAAtB,CATG,CAAP;AAUH;AACD;AACJ;AACA;AACA;AACA;AACA;;;;WACI,4BAAmB4B,GAAnB,EAAwBpG,KAAxB,EAA+B;AAAA;;AAC3B,UAAMqG,OAAO,GAAG,CAAC,GAAG9F,eAAe,CAAC+F,6BAApB,EAAmD;AAC/DC,QAAAA,EAAE,EAAE,CAAC,GAAGjG,OAAO,CAACkB,SAAZ,EAAuB,KAAKD,SAAL,EAAvB,CAD2D;AAE/DV,QAAAA,SAAS,EAAE,KAAKA,SAF+C;AAG/DqE,QAAAA,QAAQ,sBAAKkB,GAAL,EAAWpG,KAAX;AAHuD,OAAnD,CAAhB;AAKA,aAAO,KAAKwG,cAAL,CAAoBtE,IAApB,CAAyB,CAAC,GAAG9B,WAAW,CAAC+C,OAAhB,EAAyB,UAAAD,CAAC;AAAA,eAAI,MAAI,CAACuD,WAAL,CAAiBJ,OAAjB,CAAJ;AAAA,OAA1B,CAAzB,EAAmF,CAAC,GAAGjG,WAAW,CAACyD,GAAhB,EAAqB,UAAA6C,GAAG,EAAI;AAClH,YAAI,CAAC,GAAGhG,eAAe,CAACiG,mBAApB,EAAyCD,GAAzC,CAAJ,EAAmD;AAC/C,gBAAM,IAAInB,KAAJ,CAAUmB,GAAG,CAACE,KAAJ,IAAa,gCAAvB,CAAN;AACH;AACJ,OAJyF,CAAnF,CAAP;AAKH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;;;;WACI,sBAAaV,KAAb,EAAoBC,IAApB,EAA+C;AAAA;;AAAA,UAArBU,WAAqB,uEAAP,KAAO;AAC3C,UAAMR,OAAO,GAAG,CAAC,GAAG9F,eAAe,CAACuG,yBAApB,EAA+C;AAC3DP,QAAAA,EAAE,EAAE,CAAC,GAAGjG,OAAO,CAACkB,SAAZ,EAAuB,KAAKD,SAAL,EAAvB,CADuD;AAE3DV,QAAAA,SAAS,EAAE,KAAKA,SAF2C;AAG3DqF,QAAAA,KAAK,EAALA,KAH2D;AAI3DC,QAAAA,IAAI,EAAJA,IAJ2D;AAK3DU,QAAAA,WAAW,EAAXA;AAL2D,OAA/C,CAAhB;AAOA,aAAO,KAAKE,WAAL,CAAiB7E,IAAjB,CAAsB,CAAC,GAAG9B,WAAW,CAAC+C,OAAhB,EAAyB,UAAAD,CAAC;AAAA,eAAI,MAAI,CAACuD,WAAL,CAAiBJ,OAAjB,CAAJ;AAAA,OAA1B,CAAtB,EAAgF,CAAC,GAAGjG,WAAW,CAACyD,GAAhB,EAAqB,UAAA6C,GAAG,EAAI;AAC/G,YAAI,CAAC,GAAGhG,eAAe,CAACiG,mBAApB,EAAyCD,GAAzC,CAAJ,EAAmD;AAC/C,gBAAM,IAAInB,KAAJ,CAAUmB,GAAG,CAACE,KAAJ,IAAa,yBAAvB,CAAN;AACH;;AACD,eAAOF,GAAG,CAACT,OAAX;AACH,OALsF,CAAhF,CAAP;AAMH;;;WACD,kBAASI,OAAT,EAAkB;AACd,WAAKvE,EAAL,CAAQkF,QAAR,CAAiBC,IAAI,CAACC,SAAL,CAAeb,OAAf,CAAjB;AACH;;;WACD,+BAAsB;AAClB,WAAK/E,qBAAL,GAA6B6F,IAAI,CAACC,GAAL,EAA7B;AACH;;;WACD,qBAAY;AACR,UAAID,IAAI,CAACC,GAAL,KAAa,KAAK9F,qBAAlB,GAA0CX,kBAAkB,GAAG,CAAnE,EAAsE;AAClE,aAAKmB,EAAL,CAAQ4D,UAAR;AACA;AACH;;AACD,UAAI;AACA,aAAK5D,EAAL,CAAQkF,QAAR,CAAiB,GAAjB;AACH,OAFD,CAGA,OAAO3E,EAAP,EAAW,CAAG;AACjB;;;WACD,qBAAYgE,OAAZ,EAAgD;AAAA,UAA3BgB,OAA2B,uEAAjBzG,eAAiB;AAC5C,UAAM0G,KAAK,GAAGjB,OAAO,CAACE,EAAtB;;AACA,UAAI;AACA,aAAKS,QAAL,CAAcX,OAAd;AACH,OAFD,CAGA,OAAOkB,GAAP,EAAY;AACR,eAAO,CAAC,GAAGrH,MAAM,CAACsH,UAAX,EAAuBD,GAAvB,CAAP;AACH,OAP2C,CAQ5C;;;AACA,aAAO,KAAKzF,EAAL,CAAQ2C,iBAAR,CAA0BvC,IAA1B,CAA+B,CAAC,GAAG9B,WAAW,CAACqH,WAAhB,EAA6BJ,OAA7B,EAAsC,CAAC,GAAGnH,MAAM,CAACsH,UAAX,EAAuB,IAAIjC,KAAJ,mBAAqB+B,KAArB,gBAAvB,CAAtC,CAA/B,EAAuI,CAAC,GAAGlH,WAAW,CAACyC,MAAhB,EAAwB,UAAA2B,CAAC;AAAA,eAAIA,CAAC,CAAC+B,EAAF,KAASe,KAAb;AAAA,OAAzB,CAAvI,EAAqL,CAAC,GAAGlH,WAAW,CAAC0F,IAAhB,EAAsB,CAAtB,CAArL,CAAP;AACH;;;WACD,wBAAe;AACX,UAAMlB,GAAG,GAAG,CAAC,GAAGrE,eAAe,CAACmH,wBAApB,EAA8C;AACtDnB,QAAAA,EAAE,EAAE,CAAC,GAAGjG,OAAO,CAACkB,SAAZ,EAAuB,KAAKD,SAAL,EAAvB,CADkD;AAEtDV,QAAAA,SAAS,EAAE,KAAKA,SAFsC;AAGtDC,QAAAA,UAAU,EAAE,KAAKA;AAHqC,OAA9C,CAAZ;AAKA,aAAO,KAAK2F,WAAL,CAAiB7B,GAAjB,EAAsB1C,IAAtB,CAA2B,CAAC,GAAG9B,WAAW,CAACyD,GAAhB,EAAqB,UAAA6C,GAAG,EAAI;AAC1D,YAAI,CAAC,GAAGhG,eAAe,CAACiG,mBAApB,EAAyCD,GAAzC,CAAJ,EAAmD;AAC/C,gBAAM,IAAInB,KAAJ,CAAUmB,GAAG,CAACE,KAAJ,IAAa,uBAAvB,CAAN;AACH;AACJ,OAJiC,CAA3B,CAAP;AAKH;;;WACD,wBAAe;AACX,UAAMhC,GAAG,GAAG,CAAC,GAAGrE,eAAe,CAACoH,qBAApB,EAA2C;AACnDpB,QAAAA,EAAE,EAAE,CAAC,GAAGjG,OAAO,CAACkB,SAAZ,EAAuB,KAAKD,SAAL,EAAvB,CAD+C;AAEnDV,QAAAA,SAAS,EAAE,KAAKA;AAFmC,OAA3C,CAAZ;AAIA,WAAKmG,QAAL,CAAcpC,GAAd;AACH;;;WACD,gCAAuB;AACnB,UAAMA,GAAG,GAAG,CAAC,GAAGrE,eAAe,CAACqH,6BAApB,EAAmD;AAC3DrB,QAAAA,EAAE,EAAE,CAAC,GAAGjG,OAAO,CAACkB,SAAZ,EAAuB,KAAKD,SAAL,EAAvB,CADuD;AAE3DV,QAAAA,SAAS,EAAE,KAAKA;AAF2C,OAAnD,CAAZ;AAIA,WAAKmG,QAAL,CAAcpC,GAAd;AACH;;;;;;AAEL7E,OAAO,CAACE,mBAAR,GAA8BA,mBAA9B","sourcesContent":["\"use strict\";\n// Copyright (c) 2018-2022 Coinbase, Inc. <https://www.coinbase.com/>\n// Licensed under the Apache License, version 2.0\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.WalletSDKConnection = void 0;\nconst rxjs_1 = require(\"rxjs\");\nconst operators_1 = require(\"rxjs/operators\");\nconst Session_1 = require(\"../relay/Session\");\nconst types_1 = require(\"../types\");\nconst ClientMessage_1 = require(\"./ClientMessage\");\nconst DiagnosticLogger_1 = require(\"./DiagnosticLogger\");\nconst RxWebSocket_1 = require(\"./RxWebSocket\");\nconst ServerMessage_1 = require(\"./ServerMessage\");\nconst HEARTBEAT_INTERVAL = 10000;\nconst REQUEST_TIMEOUT = 60000;\n/**\n * Coinbase Wallet Connection\n */\nclass WalletSDKConnection {\n    /**\n     * Constructor\n     * @param sessionId Session ID\n     * @param sessionKey Session Key\n     * @param linkAPIUrl Coinbase Wallet link server URL\n     * @param [WebSocketClass] Custom WebSocket implementation\n     */\n    constructor(sessionId, sessionKey, linkAPIUrl, diagnostic, WebSocketClass = WebSocket) {\n        this.sessionId = sessionId;\n        this.sessionKey = sessionKey;\n        this.diagnostic = diagnostic;\n        this.subscriptions = new rxjs_1.Subscription();\n        this.destroyed = false;\n        this.lastHeartbeatResponse = 0;\n        this.nextReqId = (0, types_1.IntNumber)(1);\n        this.connectedSubject = new rxjs_1.BehaviorSubject(false);\n        this.linkedSubject = new rxjs_1.BehaviorSubject(false);\n        this.sessionConfigSubject = new rxjs_1.ReplaySubject(1);\n        const ws = new RxWebSocket_1.RxWebSocket(linkAPIUrl + \"/rpc\", WebSocketClass);\n        this.ws = ws;\n        // attempt to reconnect every 5 seconds when disconnected\n        this.subscriptions.add(ws.connectionState$\n            .pipe((0, operators_1.tap)(state => {\n            var _a;\n            return (_a = this.diagnostic) === null || _a === void 0 ? void 0 : _a.log(DiagnosticLogger_1.EVENTS.CONNECTED_STATE_CHANGE, {\n                state,\n                sessionIdHash: Session_1.Session.hash(sessionId),\n            });\n        }), \n        // ignore initial DISCONNECTED state\n        (0, operators_1.skip)(1), \n        // if DISCONNECTED and not destroyed\n        (0, operators_1.filter)(cs => cs === RxWebSocket_1.ConnectionState.DISCONNECTED && !this.destroyed), \n        // wait 5 seconds\n        (0, operators_1.delay)(5000), \n        // check whether it's destroyed again\n        (0, operators_1.filter)(_ => !this.destroyed), \n        // reconnect\n        (0, operators_1.flatMap)(_ => ws.connect()), (0, operators_1.retry)())\n            .subscribe());\n        // perform authentication upon connection\n        this.subscriptions.add(ws.connectionState$\n            .pipe(\n        // ignore initial DISCONNECTED and CONNECTING states\n        (0, operators_1.skip)(2), (0, operators_1.switchMap)(cs => (0, rxjs_1.iif)(() => cs === RxWebSocket_1.ConnectionState.CONNECTED, \n        // if CONNECTED, authenticate, and then check link status\n        this.authenticate().pipe((0, operators_1.tap)(_ => this.sendIsLinked()), (0, operators_1.tap)(_ => this.sendGetSessionConfig()), (0, operators_1.map)(_ => true)), \n        // if not CONNECTED, emit false immediately\n        (0, rxjs_1.of)(false))), (0, operators_1.distinctUntilChanged)(), (0, operators_1.catchError)(_ => (0, rxjs_1.of)(false)))\n            .subscribe(connected => this.connectedSubject.next(connected)));\n        // send heartbeat every n seconds while connected\n        this.subscriptions.add(ws.connectionState$\n            .pipe(\n        // ignore initial DISCONNECTED state\n        (0, operators_1.skip)(1), (0, operators_1.switchMap)(cs => (0, rxjs_1.iif)(() => cs === RxWebSocket_1.ConnectionState.CONNECTED, \n        // if CONNECTED, start the heartbeat timer\n        (0, rxjs_1.timer)(0, HEARTBEAT_INTERVAL))))\n            .subscribe(i => \n        // first timer event updates lastHeartbeat timestamp\n        // subsequent calls send heartbeat message\n        i === 0 ? this.updateLastHeartbeat() : this.heartbeat()));\n        // handle server's heartbeat responses\n        this.subscriptions.add(ws.incomingData$\n            .pipe((0, operators_1.filter)(m => m === \"h\"))\n            .subscribe(_ => this.updateLastHeartbeat()));\n        // handle link status updates\n        this.subscriptions.add(ws.incomingJSONData$\n            .pipe((0, operators_1.filter)(m => [\"IsLinkedOK\", \"Linked\"].includes(m.type)))\n            .subscribe(m => {\n            var _a;\n            const msg = m;\n            (_a = this.diagnostic) === null || _a === void 0 ? void 0 : _a.log(DiagnosticLogger_1.EVENTS.LINKED, {\n                sessionIdHash: Session_1.Session.hash(sessionId),\n                linked: msg.linked,\n                type: m.type,\n                onlineGuests: msg.onlineGuests,\n            });\n            this.linkedSubject.next(msg.linked || msg.onlineGuests > 0);\n        }));\n        // handle session config updates\n        this.subscriptions.add(ws.incomingJSONData$\n            .pipe((0, operators_1.filter)(m => [\"GetSessionConfigOK\", \"SessionConfigUpdated\"].includes(m.type)))\n            .subscribe(m => {\n            var _a;\n            const msg = m;\n            (_a = this.diagnostic) === null || _a === void 0 ? void 0 : _a.log(DiagnosticLogger_1.EVENTS.SESSION_CONFIG_RECEIVED, {\n                sessionIdHash: Session_1.Session.hash(sessionId),\n                metadata_keys: msg && msg.metadata ? Object.keys(msg.metadata) : undefined,\n            });\n            this.sessionConfigSubject.next({\n                webhookId: msg.webhookId,\n                webhookUrl: msg.webhookUrl,\n                metadata: msg.metadata,\n            });\n        }));\n    }\n    /**\n     * Make a connection to the server\n     */\n    connect() {\n        var _a;\n        if (this.destroyed) {\n            throw new Error(\"instance is destroyed\");\n        }\n        (_a = this.diagnostic) === null || _a === void 0 ? void 0 : _a.log(DiagnosticLogger_1.EVENTS.STARTED_CONNECTING, {\n            sessionIdHash: Session_1.Session.hash(this.sessionId),\n        });\n        this.ws.connect().subscribe();\n    }\n    /**\n     * Terminate connection, and mark as destroyed. To reconnect, create a new\n     * instance of WalletSDKConnection\n     */\n    destroy() {\n        var _a;\n        this.subscriptions.unsubscribe();\n        this.ws.disconnect();\n        (_a = this.diagnostic) === null || _a === void 0 ? void 0 : _a.log(DiagnosticLogger_1.EVENTS.DISCONNECTED, {\n            sessionIdHash: Session_1.Session.hash(this.sessionId),\n        });\n        this.destroyed = true;\n    }\n    get isDestroyed() {\n        return this.destroyed;\n    }\n    /**\n     * Emit true if connected and authenticated, else false\n     * @returns an Observable\n     */\n    get connected$() {\n        return this.connectedSubject.asObservable();\n    }\n    /**\n     * Emit once connected\n     * @returns an Observable\n     */\n    get onceConnected$() {\n        return this.connected$.pipe((0, operators_1.filter)(v => v), (0, operators_1.take)(1), (0, operators_1.map)(() => void 0));\n    }\n    /**\n     * Emit true if linked (a guest has joined before)\n     * @returns an Observable\n     */\n    get linked$() {\n        return this.linkedSubject.asObservable();\n    }\n    /**\n     * Emit once when linked\n     * @returns an Observable\n     */\n    get onceLinked$() {\n        return this.linked$.pipe((0, operators_1.filter)(v => v), (0, operators_1.take)(1), (0, operators_1.map)(() => void 0));\n    }\n    /**\n     * Emit current session config if available, and subsequent updates\n     * @returns an Observable for the session config\n     */\n    get sessionConfig$() {\n        return this.sessionConfigSubject.asObservable();\n    }\n    /**\n     * Emit incoming Event messages\n     * @returns an Observable for the messages\n     */\n    get incomingEvent$() {\n        return this.ws.incomingJSONData$.pipe((0, operators_1.filter)(m => {\n            if (m.type !== \"Event\") {\n                return false;\n            }\n            const sme = m;\n            return (typeof sme.sessionId === \"string\" &&\n                typeof sme.eventId === \"string\" &&\n                typeof sme.event === \"string\" &&\n                typeof sme.data === \"string\");\n        }), (0, operators_1.map)(m => m));\n    }\n    /**\n     * Set session metadata in SessionConfig object\n     * @param key\n     * @param value\n     * @returns an Observable that completes when successful\n     */\n    setSessionMetadata(key, value) {\n        const message = (0, ClientMessage_1.ClientMessageSetSessionConfig)({\n            id: (0, types_1.IntNumber)(this.nextReqId++),\n            sessionId: this.sessionId,\n            metadata: { [key]: value },\n        });\n        return this.onceConnected$.pipe((0, operators_1.flatMap)(_ => this.makeRequest(message)), (0, operators_1.map)(res => {\n            if ((0, ServerMessage_1.isServerMessageFail)(res)) {\n                throw new Error(res.error || \"failed to set session metadata\");\n            }\n        }));\n    }\n    /**\n     * Publish an event and emit event ID when successful\n     * @param event event name\n     * @param data event data\n     * @param callWebhook whether the webhook should be invoked\n     * @returns an Observable that emits event ID when successful\n     */\n    publishEvent(event, data, callWebhook = false) {\n        const message = (0, ClientMessage_1.ClientMessagePublishEvent)({\n            id: (0, types_1.IntNumber)(this.nextReqId++),\n            sessionId: this.sessionId,\n            event,\n            data,\n            callWebhook,\n        });\n        return this.onceLinked$.pipe((0, operators_1.flatMap)(_ => this.makeRequest(message)), (0, operators_1.map)(res => {\n            if ((0, ServerMessage_1.isServerMessageFail)(res)) {\n                throw new Error(res.error || \"failed to publish event\");\n            }\n            return res.eventId;\n        }));\n    }\n    sendData(message) {\n        this.ws.sendData(JSON.stringify(message));\n    }\n    updateLastHeartbeat() {\n        this.lastHeartbeatResponse = Date.now();\n    }\n    heartbeat() {\n        if (Date.now() - this.lastHeartbeatResponse > HEARTBEAT_INTERVAL * 2) {\n            this.ws.disconnect();\n            return;\n        }\n        try {\n            this.ws.sendData(\"h\");\n        }\n        catch (_a) { }\n    }\n    makeRequest(message, timeout = REQUEST_TIMEOUT) {\n        const reqId = message.id;\n        try {\n            this.sendData(message);\n        }\n        catch (err) {\n            return (0, rxjs_1.throwError)(err);\n        }\n        // await server message with corresponding id\n        return this.ws.incomingJSONData$.pipe((0, operators_1.timeoutWith)(timeout, (0, rxjs_1.throwError)(new Error(`request ${reqId} timed out`))), (0, operators_1.filter)(m => m.id === reqId), (0, operators_1.take)(1));\n    }\n    authenticate() {\n        const msg = (0, ClientMessage_1.ClientMessageHostSession)({\n            id: (0, types_1.IntNumber)(this.nextReqId++),\n            sessionId: this.sessionId,\n            sessionKey: this.sessionKey,\n        });\n        return this.makeRequest(msg).pipe((0, operators_1.map)(res => {\n            if ((0, ServerMessage_1.isServerMessageFail)(res)) {\n                throw new Error(res.error || \"failed to authentcate\");\n            }\n        }));\n    }\n    sendIsLinked() {\n        const msg = (0, ClientMessage_1.ClientMessageIsLinked)({\n            id: (0, types_1.IntNumber)(this.nextReqId++),\n            sessionId: this.sessionId,\n        });\n        this.sendData(msg);\n    }\n    sendGetSessionConfig() {\n        const msg = (0, ClientMessage_1.ClientMessageGetSessionConfig)({\n            id: (0, types_1.IntNumber)(this.nextReqId++),\n            sessionId: this.sessionId,\n        });\n        this.sendData(msg);\n    }\n}\nexports.WalletSDKConnection = WalletSDKConnection;\n"]},"metadata":{},"sourceType":"script"}